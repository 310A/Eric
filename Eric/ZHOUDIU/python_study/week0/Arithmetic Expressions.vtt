WEBVTT

1
00:00:00.000 --> 00:00:03.803
[SOUND] Well,

2
00:00:03.803 --> 00:00:09.341
welcome to class.

3
00:00:09.341 --> 00:00:12.392
Today, we're going to start you on your
journey of learning how to program

4
00:00:12.392 --> 00:00:12.900
in Python.

5
00:00:13.990 --> 00:00:16.998
Today's lesson is fairly straight forward,

6
00:00:16.998 --> 00:00:22.098
you've probably seen some of this in
middle school, in high school algebra.

7
00:00:22.098 --> 00:00:25.811
I'm going to tell you about how
numbers are represented in Python, and

8
00:00:25.811 --> 00:00:30.304
then we'll discuss how to do arithmetic
expressions by combining these numbers.

9
00:00:30.304 --> 00:00:34.090
I don't think it's anything
that's too mysterious here.

10
00:00:34.090 --> 00:00:37.818
Kind of what you should think about
today's lecture is that Python is course,

11
00:00:37.818 --> 00:00:39.920
just an over ground calculator.

12
00:00:39.920 --> 00:00:42.022
We're going to give it some data,
in this case, numbers, and

13
00:00:42.022 --> 00:00:43.517
we're going to ask it
to do some operations.

14
00:00:43.517 --> 00:00:46.950
And it's going to, when it's finished,
give us an answer.

15
00:00:46.950 --> 00:00:49.140
And so that will kind of consume
us through today's lecture.

16
00:00:49.140 --> 00:00:51.420
Then I'll go on and we'll talk
about ways to build variables and

17
00:00:51.420 --> 00:00:53.810
functions of things that
we'll act on later on.

18
00:00:53.810 --> 00:00:54.852
Okay, let's go to class.

19
00:00:58.704 --> 00:01:02.524
Before we jump into the details of our
lecture on arithmetic expressions,

20
00:01:02.524 --> 00:01:06.161
let me show you about how we're going to
handle examples that we're going to

21
00:01:06.161 --> 00:01:07.570
consider during lecture.

22
00:01:09.270 --> 00:01:12.440
So here,
I have a CodeSkulptor window sitting, and

23
00:01:12.440 --> 00:01:14.250
it's got the example we're
going to consider here.

24
00:01:14.250 --> 00:01:16.930
This is actually the completed example,
I'm going to walk through it and

25
00:01:16.930 --> 00:01:21.830
fill in all the Python expressions
dynamically, so you can see how I do it.

26
00:01:21.830 --> 00:01:24.432
But the critical thing is, we're going to
make that file available to you.

27
00:01:24.432 --> 00:01:26.610
It's going to, in the break
between this segment of video and

28
00:01:26.610 --> 00:01:30.460
the next, we're going to pop up
a URL that you can click on, and

29
00:01:30.460 --> 00:01:33.970
it will take you to this
file inside CodeSkulptor.

30
00:01:33.970 --> 00:01:38.680
And you can kind of see up here, there's
actually a naming convention we have.

31
00:01:38.680 --> 00:01:43.070
It's always codeskulptor.org, and
we put a hash mark with examples.

32
00:01:43.070 --> 00:01:45.868
And then afterwards,
we'll have the lecture name.py.

33
00:01:45.868 --> 00:01:48.134
Now you don't have to remember that,
but then go up here,

34
00:01:48.134 --> 00:01:49.690
you can click on it, pull it up.

35
00:01:49.690 --> 00:01:52.200
And you can play around with
it either during the video or

36
00:01:52.200 --> 00:01:53.430
after the video is over.

37
00:01:55.322 --> 00:01:57.700
All right, let's talk about numbers and
arithmetic expressions.

38
00:01:58.760 --> 00:02:02.369
So to begin, let's just dive right in and
have Python pronounce some numbers.

39
00:02:02.369 --> 00:02:06.272
So let's print 3, and -1, and

40
00:02:06.272 --> 00:02:10.453
3.14159, maybe -2.8.

41
00:02:10.453 --> 00:02:15.240
So if I hit run here, sure enough,
out come those numbers.

42
00:02:15.240 --> 00:02:19.772
Now the thing to notice that in Python,
there are actually two types of numbers,

43
00:02:19.772 --> 00:02:23.454
they're kind of signed whole numbers,
things like 3 and -1.

44
00:02:23.454 --> 00:02:26.868
And then there are decimal numbers that
are kind of have fractional parts and

45
00:02:26.868 --> 00:02:29.610
always have kind of a decimal point here.

46
00:02:29.610 --> 00:02:33.537
And in Python, those signed whole numbers
are called ints, for integers, and

47
00:02:33.537 --> 00:02:38.120
kind of the decimal numbers are called
floats for floating point numbers.

48
00:02:38.120 --> 00:02:41.258
And if you are ever in any doubt about
kind of, what kind of number you're

49
00:02:41.258 --> 00:02:44.603
working with, there is a function in
Python that can actually tell you kind of

50
00:02:44.603 --> 00:02:47.345
what type of number you're working with,
it's called type.

51
00:02:47.345 --> 00:02:50.486
So I could say type(3) or

52
00:02:50.486 --> 00:02:56.086
maybe type(3.14159), if I run that,

53
00:02:56.086 --> 00:03:02.925
well, I'm going to guess this is an int,
and this is a float.

54
00:03:02.925 --> 00:03:06.586
Let's run it, sure enough,
it's an int, this is a float.

55
00:03:06.586 --> 00:03:14.890
Now here's a little trickier test, what
happens if we ask for the type of 3.0?

56
00:03:14.890 --> 00:03:18.590
Now if you look at it, really,
this is really a whole number, but

57
00:03:18.590 --> 00:03:21.430
somehow it's kind of got
this 0 fractional part.

58
00:03:21.430 --> 00:03:24.390
So in Python, this is going to be a float.

59
00:03:24.390 --> 00:03:27.502
In fact, the way we're going to know we're
working with a float is we always have

60
00:03:27.502 --> 00:03:28.739
a decimal point here, a .0.

61
00:03:29.820 --> 00:03:33.930
Now there's some functions that we can use
to move back and forth between ints and

62
00:03:33.930 --> 00:03:36.237
floats, and they're not too complicated.

63
00:03:36.237 --> 00:03:38.660
In fact,
they're just the function int and float.

64
00:03:38.660 --> 00:03:43.472
So I can convert something
that is a floating point

65
00:03:43.472 --> 00:03:48.180
number into an integer
in the following manner.

66
00:03:51.299 --> 00:03:53.511
And so, these are going to
return back some integers and

67
00:03:53.511 --> 00:03:55.900
kind of what integer are we
always going to get?

68
00:03:55.900 --> 00:03:56.950
Well, the rule is,

69
00:03:56.950 --> 00:03:59.730
we're always going to get the whole
part of this decimal number here.

70
00:03:59.730 --> 00:04:03.050
So we're just going to throw away the part
to the right of the decimal point.

71
00:04:04.260 --> 00:04:09.270
We can also go through and
convert an integer into a float.

72
00:04:11.810 --> 00:04:14.576
That, again, seems kind of crazy because,

73
00:04:14.576 --> 00:04:17.430
well, an integer kind of
is a decimal number.

74
00:04:17.430 --> 00:04:21.330
But what you're going to see is the way
Python represents this is, well,

75
00:04:21.330 --> 00:04:23.970
it's going to simply put .0 here.

76
00:04:23.970 --> 00:04:27.977
Okay, so when you see 3.0,
that's really telling you this is a float,

77
00:04:27.977 --> 00:04:29.450
-1.0, that's a float.

78
00:04:32.700 --> 00:04:36.390
Now, before we move on to talk
about arithmetic operations,

79
00:04:36.390 --> 00:04:42.150
let me give you a few words of wisdom
about dealing with floating point numbers.

80
00:04:43.250 --> 00:04:48.220
Floating point numbers are only
an approximation to a decimal number.

81
00:04:48.220 --> 00:04:53.195
For example, when you do 1 divided by 3,
you expect a decimal representation of

82
00:04:53.195 --> 00:04:57.610
something like 0.33333333,
where the 3 repeats forever.

83
00:04:58.720 --> 00:05:02.160
Computers are not really great at
representing that kind of information.

84
00:05:03.380 --> 00:05:04.050
In fact,

85
00:05:04.050 --> 00:05:09.830
a number like pi doesn't even have kind
of even a nice repeating representation.

86
00:05:09.830 --> 00:05:15.066
There's a famous episode of Star Trek
where Mr. Spock calms a rebellious

87
00:05:15.066 --> 00:05:21.076
computer by asking the computer to compute
the value of pi to the last decimal digit.

88
00:05:21.076 --> 00:05:24.849
And the computer whirs off and
goes into an infinite loop,

89
00:05:24.849 --> 00:05:28.247
desperately trying to
compute the last digit of pi.

90
00:05:28.247 --> 00:05:32.600
People have built a computer taking this
class, they have a time out here or there.

91
00:05:32.600 --> 00:05:36.581
But the critical question is kind
of what goes on inside Python,

92
00:05:36.581 --> 00:05:39.960
whenever you give it a number
that has lot of digits.

93
00:05:39.960 --> 00:05:41.030
What does Python do?

94
00:05:41.030 --> 00:05:45.610
So let me show you kind of two examples
real quick here to help you understand.

95
00:05:45.610 --> 00:05:49.340
So what I've gone out to have done is
I've actually grabbed two really good

96
00:05:49.340 --> 00:05:54.580
approximations for pi and
the square root of 2, so here I have,

97
00:05:54.580 --> 00:06:00.640
this is kind of a 50 digit
approximation of pi.

98
00:06:00.640 --> 00:06:02.668
And then I've also gone and

99
00:06:02.668 --> 00:06:07.614
I've grabbed a 50 digit approximation
to the square root of 2.

100
00:06:09.941 --> 00:06:14.312
So I'm going to actually ask Python now
to print these out, and when you do that,

101
00:06:14.312 --> 00:06:16.510
notice that I lost a lot of digits here.

102
00:06:16.510 --> 00:06:19.080
All these digits here
kind of got trimmed down.

103
00:06:19.080 --> 00:06:21.850
All these digits here got trimmed down.

104
00:06:21.850 --> 00:06:26.563
So what happens inside Python is they
represent floating point numbers of about

105
00:06:26.563 --> 00:06:28.613
15 decimal digits of accuracy.

106
00:06:28.613 --> 00:06:30.620
So anything beyond that gets thrown away.

107
00:06:31.660 --> 00:06:35.890
So in particular, occasionally, when
you're doing arithmetic operations using

108
00:06:35.890 --> 00:06:39.165
floating point numbers,
you're going to get answers of the form,

109
00:06:39.165 --> 00:06:41.919
4 point and a bunch of 0s and
then maybe a 3 at the end.

110
00:06:41.919 --> 00:06:45.255
What you're seeing here is something
called floating point error.

111
00:06:45.255 --> 00:06:48.705
Whereas Python is doing the computation,

112
00:06:48.705 --> 00:06:52.345
it can't do the exact precise
operation that you're specifying.

113
00:06:52.345 --> 00:06:55.940
It can't compute pi to
the last decimal point or

114
00:06:55.940 --> 00:06:58.305
one-third to the last decimal point.

115
00:06:58.305 --> 00:07:01.045
So it has to do some approximation.

116
00:07:01.045 --> 00:07:04.315
So you're seeing that approximation
error there inside that computation.

117
00:07:09.690 --> 00:07:11.977
All right,
we talked about numbers in Python.

118
00:07:11.977 --> 00:07:16.903
Let's talk about the arithmetic
operators that you have available to do

119
00:07:16.903 --> 00:07:19.070
computations in Python.

120
00:07:19.070 --> 00:07:22.440
Here's a list of kind of some of
the bare basic arithmetic operators.

121
00:07:22.440 --> 00:07:28.153
We have plus, minus,
times, division, power.

122
00:07:28.153 --> 00:07:30.100
It's fairly straightforward.

123
00:07:30.100 --> 00:07:36.072
We just take two numbers and
apply the operator to them,

124
00:07:36.072 --> 00:07:40.265
so we can say something like 1+2, or

125
00:07:40.265 --> 00:07:45.110
3-4, or 5*6, or 2 to the 5th power.

126
00:07:46.260 --> 00:07:50.836
And if we run that, out comes 3-1,

127
00:07:50.836 --> 00:07:54.560
30, and to the 5th is 32.

128
00:07:54.560 --> 00:07:59.880
One operator that you should pay
attention to in Python is division.

129
00:07:59.880 --> 00:08:04.555
So, the way the division operator
works in Python 2 is different

130
00:08:04.555 --> 00:08:07.026
than the way it works in Python 3.

131
00:08:07.026 --> 00:08:11.296
In Python 2, if one of the operators is a
floating point number, then the result of

132
00:08:11.296 --> 00:08:15.990
division is also a floating point number,
and it approximates the actual division.

133
00:08:15.990 --> 00:08:19.760
So, for example,

134
00:08:19.760 --> 00:08:25.886
I could say print 1.0/3,

135
00:08:25.886 --> 00:08:30.599
or 5.0/2.0, or

136
00:08:30.599 --> 00:08:33.908
-7/3.0.

137
00:08:33.908 --> 00:08:38.794
And what would come out when I
run that is what I'd expect,

138
00:08:38.794 --> 00:08:45.200
kind of a decimal approximation of 1/3,
5/2, and kind of -7/3.

139
00:08:46.560 --> 00:08:50.970
Notice if both the operators
are actually integers, well,

140
00:08:50.970 --> 00:08:55.215
Python returns kind of the integer
version of the answer.

141
00:08:55.215 --> 00:08:58.723
And that particular case is kind of
the next lowest integer after you do

142
00:08:58.723 --> 00:09:00.050
the exact division.

143
00:09:00.050 --> 00:09:04.770
So for example, if I say print 1/3,

144
00:09:04.770 --> 00:09:11.500
5/2, -7/3,

145
00:09:11.500 --> 00:09:16.110
we run that, the answer comes out to be,

146
00:09:16.110 --> 00:09:19.425
well, one integer divided by 3 is 0.

147
00:09:19.425 --> 00:09:21.589
We kind of round it down.

148
00:09:21.589 --> 00:09:26.970
2.5, well, let's see, 5/2,
integer answer would be 2 here.

149
00:09:26.970 --> 00:09:29.272
We kind of rounded 2.5 down.

150
00:09:29.272 --> 00:09:36.017
We do -7/3, well,
integer division is actually -1/3.

151
00:09:36.017 --> 00:09:40.306
I'm actually talk about division more
later on when we talk about remainders,

152
00:09:40.306 --> 00:09:44.737
and we'll have a second operator called
//, is explicitly integer division.

153
00:09:49.553 --> 00:09:53.560
All right, we know about numbers,
we know about arithmetic operators.

154
00:09:53.560 --> 00:09:55.480
Now we're ready to build
arithmetic expressions.

155
00:09:56.500 --> 00:09:58.930
So, the idea is fairly simple.

156
00:09:58.930 --> 00:10:02.730
An arithmetic expression
is either a number, or

157
00:10:02.730 --> 00:10:07.050
it's an arithmetic operator applied
to two arithmetic expressions.

158
00:10:07.050 --> 00:10:10.570
Just kind of our first example
of kind of recursive definition.

159
00:10:10.570 --> 00:10:14.815
So, for example,
2 is an arithmetic expression, 2+3,

160
00:10:14.815 --> 00:10:19.226
it's an arithmetic expression
because we've applied the plus

161
00:10:19.226 --> 00:10:22.920
operator to two arithmetic expressions,
2 and 3.

162
00:10:24.090 --> 00:10:26.610
Now in practice, you don't even really
need to understand that definition.

163
00:10:26.610 --> 00:10:28.380
You can just simply go through and

164
00:10:28.380 --> 00:10:32.920
type in expressions that you're used to
using from, say, middle school algebra.

165
00:10:32.920 --> 00:10:39.200
So I could say 1 + 2 * 3,

166
00:10:39.200 --> 00:10:46.301
or 4.0- 5.0 / 6.0,

167
00:10:46.301 --> 00:10:51.778
or 7 * 8 + 9 * 10.

168
00:10:51.778 --> 00:10:57.080
And if I hit run,
what comes out is exactly what I'd expect.

169
00:10:57.080 --> 00:10:59.160
Now you might kind of say, well,

170
00:10:59.160 --> 00:11:03.630
how did I go from this definition kind
of involving an arithmetic expression.

171
00:11:03.630 --> 00:11:06.204
It's an arithmetic expression
combined with operators,

172
00:11:06.204 --> 00:11:10.070
to this thing that I just typed in that's
just kind of this flat expression mean.

173
00:11:10.070 --> 00:11:13.559
I typed in 1 + 2 * 3, so somehow,

174
00:11:13.559 --> 00:11:18.639
Python knew that this was really 1 +,
then 2 * 3.

175
00:11:18.639 --> 00:11:20.834
It turns out there's this
notion of precedence, and

176
00:11:20.834 --> 00:11:23.850
you probably studied this
in middle school algebra.

177
00:11:23.850 --> 00:11:27.450
And in fact, you probably have a mnemonic
you learned at one point, maybe remember,

178
00:11:27.450 --> 00:11:31.070
which was,
please excuse my dear aunt Sally.

179
00:11:31.070 --> 00:11:34.140
So, the first letter of that phrase,
of each word in that phrase,

180
00:11:34.140 --> 00:11:37.370
gives us the order in which
we should do operations,

181
00:11:37.370 --> 00:11:40.510
when we're taking kind of this linear
version of an expression trying to think

182
00:11:40.510 --> 00:11:44.040
about it in terms of this
kind of recursive definition.

183
00:11:44.040 --> 00:11:45.920
So it says that when we're
evaluating expressions,

184
00:11:45.920 --> 00:11:48.360
we should alway do parentheses first.

185
00:11:48.360 --> 00:11:51.070
And then after that,
we should always do exponentiation next.

186
00:11:52.230 --> 00:11:55.253
Then we should go through and
do multiplication and division, m and d.

187
00:11:55.253 --> 00:11:57.210
And in fact, those have equal precedence.

188
00:11:57.210 --> 00:12:00.210
So if we have a sequence of those,
we just do them from left to right.

189
00:12:00.210 --> 00:12:03.440
And then finally, we do addition and
subtraction last.

190
00:12:04.570 --> 00:12:12.096
So for example,
let's type in an expression here,

191
00:12:12.096 --> 00:12:17.920
say, print 1 * 2, 1 * 2 + 3 * 4.

192
00:12:17.920 --> 00:12:19.291
And if you look at that,

193
00:12:19.291 --> 00:12:24.190
the rules of precedence say that we
should do multiplication before addition.

194
00:12:24.190 --> 00:12:29.184
So this is really
the same thing as 2 + 12.

195
00:12:29.184 --> 00:12:34.170
So if I run that, sure enough,
I get 14 back from both of them.

196
00:12:34.170 --> 00:12:35.780
And notice, here's kind of the real rule,

197
00:12:35.780 --> 00:12:38.880
which is if you're in doubt about
the order in which operations take place,

198
00:12:38.880 --> 00:12:41.720
you can always just go through and
use parentheses.

199
00:12:41.720 --> 00:12:44.495
So for example,

200
00:12:44.495 --> 00:12:50.439
if I wanted to do that 2 + 3 first,

201
00:12:50.439 --> 00:12:56.595
I can say 1 + 1 * (2 + 3) * 4.

202
00:12:56.595 --> 00:13:04.843
And that should be the same
thing as 1 * 5 * 4.

203
00:13:04.843 --> 00:13:06.560
And sure enough,
these both evaluate to 20.

204
00:13:08.920 --> 00:13:10.210
So in practice,

205
00:13:10.210 --> 00:13:14.310
working with arithmetic expressions
inside Python is very intuitive.

206
00:13:14.310 --> 00:13:17.380
It's really what you learned
in middle school algebra.

207
00:13:17.380 --> 00:13:20.130
So I don't think you'll find
anything real too tricky here.

208
00:13:20.130 --> 00:13:21.740
So go ahead and take a shot at it.